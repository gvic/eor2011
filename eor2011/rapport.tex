\documentclass[]{report}   % list options between brackets
\usepackage{}              % list packages between braces

% type user-defined commands here

% GESTION LANGUE FRANCAISE
\usepackage[francais]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}

% GESTION DES ACCENTS
%\usepackage[utf8]{inputenc}  

\begin{document}

\title{Projet long d'intergiciels : \\Service de partage d'objets
  dupliqués en Java}   % type title between braces
\author{Paul Bonaud\\Victor Godayer}         % type author(s) between braces
\date\today    % type date between braces
\maketitle

\begin{abstract}
  Ce projet avait pour but de nous faire développer un service de gestion
  d'objet partagés.
  Pour l'utilisateur, le service accessible est interfacé par un objet
  nommé \textit{SharedObject}.
  La gestion de la cohérence est prise en main par le backend (i.e. la couche
  client et la couche serveur).

  La compilation du projet se fait par le script \textit{compile}
  situe à la racine de l'archive fournie.
\end{abstract}

\section{Introduction}
Par soucis de concision nous avons choisi de ne pas présenter le
service, étant donné que vous etes le fournisseur des spécifications
ainsi que le lecteur du rapport...
On ne parlera donc que des choix de conception et des problèmes rencontrés.


\section{Conception}
\subsection{SharedObject}

\paragraph{}
Cette entité a pour rôle d'implanter les méthodes métier du service. 
On y trouve également les \textit{callbacks} que le
serveur appelle lorsqu'il a besoin d'invalider un écrivain, un
lecteur, ou de réduire le verrou.

\paragraph{}
En terme de synchronisation nous avons du faire attention à 3
choses.

\paragraph{}
La premiére a été d'attendre qu'une quelconque invalidation ou
réduction de verrou soit terminée avant d'executer une méthode métier
du service.
Nous avons mis en oeuvre cette technique en notifiant la fin de
l'appel d'une méthode d'invalidation grâce à \textit{notify}.
Du côté métier, la méthode \textit{wait} attend cette notification
s'il y a lieu d'attendre, avant d'opérer dans la modification de
la valeur du verrou.

\paragraph{}
La deuxième concerne les méthodes dites \textit{callback}.
Elle concerne spécialement le changement d'un verrou, lorsque celui ci
est dans l'état \emph{taken}.
Lorsqu'il est dans cet état, il est impératif d'attendre que
l'utilisateur déverouille l'objet avant de pouvoir faire quoi que ce
soit.
Cette attente est implantée par la même méthode \textit{wait} que
précédement. 
C'est lors de l'appel de la méthode \textit{unlock} que l'execution du
\textit{callback} sera réveillé par \textit{notify}.
A la suite d'un déverouillage de l'objet par l'utilisateur, le verrou
se trouve dans l'état \textit{cached}. Il faut donc le positionner à
la valeur spécifiée par les automates.

\paragraph{}
La troisième chose consiste à envoyer la requête de verouillage au
serveur sans créer de \textit{deadlocks}.
Sachant que l'objet \textit{SharedObject} doit être synchronisé durant
le changement de la valeur de son verrou, il faut envoyer la requête
vers le serveur en dehors du bloc synchronisé pour éviter tout interblocage.

\paragraph{}
Pour l'étape 3, il a fallu spécifier la méthode \textit{readResolve}.
Celle-ci afin de spécifier la deserialization d'un \textit{sharedObject}. Chez
un client, on vérifie si le sharedObject que l'on deserialize n'est pas déjà
présent dans celui-ci. S'il n'est pas présent on doit le créer dans le client en
récuperant son objet auprès du serveur.

Nous avons également ajouter deux méthodes simples
\textit{SharedObject lookup(int id)} et 
\textit{void add(int id, SharedObject\_itf so)} dans la classe Client pour cela.


\subsection{Client}
Rien de très compliqué dans la version de l'étape 1.
Pour ce qui est de l'étape 2, il faut instancier l'objet partagé par
le constructeur du \textit{stub}.
Ceci est réalisé dans la méthode \textit{instanciateStub}.

\subsection{Server}
Rien à préciser, tout était clairement spécifier dans le sujet du
projet.

On voit qu'il est nécessaire de synchroniser l'accès à l'objet
\textit{idCpt}, de manière à éviter des incrémentations cahotiques et
ingérables. Ainsi on préserve la propriété d'unicité de
l'identifiant libéré.

\subsection{ServerObject}

Les méthodes \textit{lock\_read} et \textit{lock\_write} sont
\textit{synchronized} pour rendre impossible leur execution simultanée.
Ainsi on évite des problèmes de cohérence.

\section{Tests}

\subsection{IRC}
L'application \textit{IRC} fournie, a permis de vérifier les bases du service.
Mais ceci sans accès concurrents. Aprés le codage 'simple' du service, sans
synchronisation particulière, nous avons pu valider le principe de base du
service d'objets dupliqués.

Cette application simple nous a donc permis de tester en partie les étapes 1 et
2.
Pour tester l'accès concurrent et la cohérence des objets dupliqués, nous avons
implanter une application dites de 'stress'.

\subsection{Stress Test}
L'application de stress utilisée est simple. Un seul objet partagé au sein du
serveur, accédé par un nombre quelconque de clients en meme temps (avec
écriture ou lecture possible par chaque client). Par simplicité nous avons
choisi un entier comme objet partagé. Sur lequel nous effectuerons des incrémentations ou
des remises à zero.
Nous avons donc implanté \textit{ClientSimple} qui regroupe les
fonctionnalitées suivantes grâce à une interface graphique:
\begin{itemize}
\item (écritures 'infinies') incrémentation de l'entier en continu.
\item (lectures n fois) lecture de la valeur de l'entier n fois à la suite. (n
paramétrable par l'IHM).
\item (une écriture) remise à zero de l'entier.
\item (écritures ou lectures 'infinies') incrémentation ou lecture aléatoirement
en continu.
\item (rien) pause du client.\\
\end{itemize}

Cette application a été très utile puisqu'en la lancant sur 3 JVM
différentes (ou plus), nous avons pu détecter des problèmes de
cohérences et de deadlocks sur les \textit{SharedObject}. 

\section{Repartition du travail}
Nous nous sommes occuper de la partie 1 ensemble (reflexion et
codage). Pour le codage, l'un s'est occupé principalement du codage du service
et l'autre de l'application de stress test.
Bien que nous ayons reflechis ensemble sur les deux dernières parties, nous
avons séparé la phase de \textit{codage}: l'un a codé la partie 2 et l'autre la partie 3.


\section{Conclusion}

L'étape 1 a été sans doute la plus dur a debugger.
Trouver la cause des \textit{deadlocks} n'était pas toujours évident 
compte tenu des communications rmi client-serveur et serveur-client.
Nous nous sommes vite rendu compte que les outils habituels de
débuggage étaient inutilisables...

C'est pourquoi la réflexion sur le papier nous a porter secours!

L'étape 2 était simplement du codage avec lecture de documentation
de Java.

L'étape 3 nous a demandé une certaine reflexion au niveau de la
deserialization des objets. 
Mais une fois le concept compris, l'implantation ne posait pas de
difficultés particulières.

D'un point de vu personnel, on en ressort avec de l'expérience au
niveau des concepts de synchronisation et du service offert par rmi.

De plus on comprend mieux comment sont structurées et comment
fonctionnent les applications réparties.
En effet ce projet permet de bien comprendre le partage d'objets entre
plusieurs machines.

\end{document}
