\documentclass[]{report}   % list options between brackets
\usepackage{}              % list packages between braces

% type user-defined commands here

% GESTION LANGUE FRANCAISE
\usepackage[francais]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}

% GESTION DES ACCENTS
%\usepackage[utf8]{inputenc}  

\begin{document}

\title{Projet long d'intergiciels : \\Service de partage d'objets
  dupliqués en Java}   % type title between braces
\author{Paul Bonaud\\Victor Godayer}         % type author(s) between braces
\date\today    % type date between braces
\maketitle

\begin{abstract}
  Ce projet avait pour but de nous faire développer un service de gestion
  d'objet partagés.
  Pour l'utilisateur, le service accessible est interfacé par un objet
  nommé \textit{SharedObject}.
  La gestion de la cohérence est prise en main par le backend (i.e. la couche
  client et la couche serveur).
\end{abstract}

\section{Introduction}
Par soucis de concision nous avons choisi de ne pas présenter le
service, étant donné que vous êtes le fournisseur des spécifications
ainsi que le lecteur du rapport...
On ne parlera donc que des choix de conception et des problèmes rencontrés.


\section{Conception}
\subsection{SharedObject}

\paragraph{}
Cette entité a pour rôle d'implanter les méthodes métier du service. 
On y trouve également les \textit{callback} que le
serveur appelle lorsqu'il a besoin d'invalider un écrivain, un
lecteur, ou de réduire le verrou.

\paragraph{}
En terme de synchronisation nous avons du faire attention à 3
choses.

\paragraph{}
La première a été d'attendre qu'une quelconque invalidation ou
réduction de verrou soit terminée avant d'executer une méthode métier
du service.
Nous avons mis en oeuvre cette technique en notifiant la fin de
l'appel d'une méthode d'invalidation grâce à \textit{notify}.
Du côté métier, la méthode \textit{wait} attendait cette notification
s'il y avait lieu d'attendre, avant d'opérer dans la modification de
la valeur du verrou.

\paragraph{}
La deuxième concerne les méthodes dites \textit{callback}.
Elle concerne spécialement le changement d'un verrou, lorsque celui ci
est dans l'état \emph{taken}.
Lorsqu'il est dans cet état, il est impératif d'attendre que
l'utilisateur déverouille l'objet avant de pouvoir faire quoi que ce
soit.
Cet attente est implanter par la même méthode \textit{wait} que
précédement. 
C'est lors de l'appel de la méthode \textit{unlock} que l'execution du
\textit{callback} sera réveillé.
A la suite d'un déverouillage de l'objet par l'utilisateur, le verrou
se trouve dans l'état \textit{cached}. Il faut donc le positionner à
la valeur spécifier par les automates.

\paragraph{}
La troisième chose consiste à envoyer la requete de verouillage au
serveur sans créer de \textit{deadlocks}.
Sachant que l'objet 





\subsection{Client}
Rien de très compliqué dans la version de l'étape 1.
Pour ce qui est de l'étape 2, il faut instancier l'objet partagé par
le constructeur du \textit{stub}.
Ceci est réalisé dans la méthode \textit{instanciateStub}.

\subsection{Server}
Rien à préciser, tout était clairement spécifier dans le sujet du
projet.

Peut être un mot sur le synchonized(idCpt)...

\subsection{ServerObject}

Les méthodes \textit{lock\_read} et \textit{lock\_write} sont
\textit{synchronized} pour rendre impossible leur execution simultané.
Ainsi on évite des problèmes de cohérence.


\section{Repartition du travail}
Nous nous sommes occuper de la partie 1 ensemble (reflexion et
codage).
Bien que nous ayont réfléchis ensemble sur les deux dernières parties,
nous avons séparer la phase de \textit{codage}:
l'un a codé la partie 2 et l'autre la partie 3.

\end{document}
